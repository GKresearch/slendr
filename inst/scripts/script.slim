// This SLiM script serves as a simulation back end of the slendr package.
// As such it is distributed under the same conditions and license as the
// rest of the slendr R package codebase.

///
/// Initialization block
///
initialize() {
    // if the script is being run in SLiMgui, specify dummy values for
    // total sequence length and recombination rate
    if (exists("slimgui")) {
        defineConstant("SEQUENCE_LENGTH", 1);
        defineConstant("RECOMB_RATE", 0);
    } else {
        required_arg("SEQUENCE_LENGTH");
        required_arg("RECOMB_RATE");
    }

    optional_arg("SEED", getSeed());
    setSeed(SEED); catn("SEED: " + getSeed());

    required_arg("OUTPUT_TS");
    optional_arg("MODEL", "."); // directory containing model configuration files
    optional_arg("SAMPLES", ""); // path to a table with the sampling schedule
    optional_arg("SPATIAL", fileExists(config_path("maps.tsv"))); // is the model spatial?
    optional_arg("OUTPUT_LOCATIONS", ""); // where should locations of individuals be saved?
    optional_arg("COALESCENT_ONLY", T); // only keep coalescent nodes?
    optional_arg("BURNIN_LENGTH", 0); // length of the burnin period in generations
    optional_arg("SIMULATION_LENGTH", // total length of the simulation in generations
                 asInteger(readFile(config_path("length.txt"))));

    // how many attempts should be made to place an offspring on a map before
    // discarding it?
    optional_arg("MAX_ATTEMPTS", 1);

    // model configuration tables
    defineConstant("POPULATIONS", read_table(config_path("populations.tsv")));
    defineConstant("GENEFLOWS", read_table(config_path("geneflow.tsv")));
    defineConstant("RESIZES", read_table(config_path("resizes.tsv")));
    defineConstant("SAMPLING", read_table(SAMPLES));

    defineConstant("DESCRIPTION", readFile(config_path("description.txt")));

    if (SPATIAL) {
        defineConstant("INTERACTIONS", read_table(config_path("dispersals.tsv")));
        defineConstant("MAPS", read_table(config_path("maps.tsv")));

        // load all spatial maps (image objects)
        MAPS.setValue("image", sapply(config_path(MAPS.getValue("path")), "Image(applyValue);"));

        // world map dimensions
        defineConstant("WIDTH", MAPS.getValue("image")[0].width);
        defineConstant("HEIGHT", MAPS.getValue("image")[0].height);

        initializeSLiMOptions(keepPedigrees = T, dimensionality = "xy");

        // generate interaction types (two for each population - competition and mating)
        for (i in POPULATIONS.getValue("pop_id")) {
            competition = filter(INTERACTIONS, "pop_id", i).getValue("competition")[0];
            mating = filter(INTERACTIONS, "pop_id", i).getValue("mating")[0];

            initializeInteractionType(2 * i, "xy", reciprocal = T, maxDistance = competition);
            initializeInteractionType(2 * i + 1, "xy", reciprocal = T, maxDistance = mating);
        }
    } else {
        initializeSLiMOptions(keepPedigrees = T);
        defineConstant("INTERACTIONS", NULL);
        defineConstant("MAPS", NULL);
    }

    defineConstant("SIMULATION_START", BURNIN_LENGTH + min(POPULATIONS.getValue("tsplit_gen")));
    defineConstant("SIMULATION_END", SIMULATION_START + SIMULATION_LENGTH);

    initializeTreeSeq(retainCoalescentOnly = COALESCENT_ONLY);

    initializeMutationType("m0", 0.5, "f", 0.0);
    initializeGenomicElementType("g1", m0, 1.0);
    initializeGenomicElement(g1, 0, SEQUENCE_LENGTH - 1);
    initializeMutationRate(0);

    initializeRecombinationRate(RECOMB_RATE);
}

1 early() /* Schedule script block events */ {
    // start of the burnin and of the simulation itself
    community.rescheduleScriptBlock(s0, ticks = SIMULATION_START);

    // population splits
    community.rescheduleScriptBlock(s1, ticks = unique(c(1, BURNIN_LENGTH + POPULATIONS.getValue("tsplit_gen"))));

    // geneflow events
    if (num_rows(GENEFLOWS)) {
        community.rescheduleScriptBlock(s2, ticks = BURNIN_LENGTH + unique(GENEFLOWS.getValue("tstart_gen")));
        community.rescheduleScriptBlock(s3, ticks = BURNIN_LENGTH + unique(GENEFLOWS.getValue("tend_gen")));
    } else {
        community.deregisterScriptBlock(s2);
        community.deregisterScriptBlock(s3);
    }

    // spatial map changes
    if (num_rows(MAPS))
         community.rescheduleScriptBlock(s4, ticks = unique(c(1, BURNIN_LENGTH + MAPS.getValue("time_gen"))));
    else
         community.deregisterScriptBlock(s4);

    // step population size changes
    step_changes = filter(RESIZES, "how", "step");
    if (num_rows(step_changes))
        community.rescheduleScriptBlock(s5, ticks = BURNIN_LENGTH + unique(step_changes.getValue("tresize_gen")));
    else
        community.deregisterScriptBlock(s5);

    // exponential population size changes
    exp_changes = filter(RESIZES, "how", "exponential");
    if (num_rows(exp_changes)) {
        // extract times of all scheduled exponential size changes
        times = c();
        for (i in seqLen(num_rows(exp_changes))) {
            event = exp_changes.getRowValues(i);
            times = c(times, event.getValue("tresize_gen") : event.getValue("tend_gen"));
        }
        community.rescheduleScriptBlock(s6, ticks = BURNIN_LENGTH + unique(times));
    } else
        community.deregisterScriptBlock(s6);

    // set interaction distances and dispersals
    if (num_rows(INTERACTIONS))
        community.rescheduleScriptBlock(s7, ticks = unique(c(1, BURNIN_LENGTH + INTERACTIONS.getValue("tdispersal_gen"))));
    else
        community.deregisterScriptBlock(s7);

    // output locations of individuals
    if (OUTPUT_LOCATIONS != "" & SPATIAL) {
        community.rescheduleScriptBlock(s8, start = SIMULATION_START, end = SIMULATION_END);
        write_locations_header();
    } else
        community.deregisterScriptBlock(s8);

    // remember individuals for tree sequence recording
    community.rescheduleScriptBlock(s10, start = SIMULATION_START, end = SIMULATION_END);

    // remove populations from the simulation
    cleanups = filter(POPULATIONS, "tremove_gen", -1, negate = T);
    if (num_rows(cleanups))
         community.rescheduleScriptBlock(s11, ticks = BURNIN_LENGTH + unique(cleanups.getValue("tremove_gen")));
    else
         community.deregisterScriptBlock(s11);

    // save data and stop the simulation
    community.rescheduleScriptBlock(s12, ticks = SIMULATION_END);
}

///
/// Scheduled event script blocks
///

s0 late() /* Log the start of the simulation */ {
    if (community.tick == 1 & BURNIN_LENGTH > 0)
        log_output("start of burnin");
    else
        log_output("starting the simulation");
}

s1 late() /* Population splits */ {
    pops = filter(POPULATIONS, "tsplit_gen", c(1, community.tick - BURNIN_LENGTH));

    for (i in seqLen(num_rows(pops))) {
        pop = pops.getRowValues(i);
        // skip over ancestral populations, who have been created in generation 1
        if (community.tick > 1 & pop.getValue("tsplit_gen") == 1) next;
        create_pop(pop);
    }

    community.allInteractionTypes.evaluate(sim.subpopulations);
}

s2 late() /* Geneflow events */ {

}

s3 late() /* Stopping geneflow */ {

}

s4 late() /* Update spatial population boundaries */ {

}

s5 /* Step population size changes */ early() {

}

s6 /* Exponential population size changes */ early() {

}

s7 late() /* Changing interaction distances and dispersals */ {

}

s8 late() /* Save locations of all individuals */ {

}

s10 late() /* Remember individuals for tree sequence recording */ {

if (community.tick == SIMULATION_END) {
        inds = sample(sim.subpopulations.individuals, 5);

        replace_which = SAMPLING.getValue("n") == INF;
            n_values = SAMPLING.getValue("n");
            n_values[replace_which] = 5;
            SAMPLING.setValue("n", n_values);
        inds.tag = 1; // tag sampled individuals as remembered
        sim.treeSeqRememberIndividuals(inds, permanent = T);
        }
}

1: late() /* Retain all individuals in each generation */ {
    sim.treeSeqRememberIndividuals(sim.subpopulations.individuals, permanent = F);
}

s11 late() /* Schedule removal of populations */ {

}

s12 late() /* End of simulation */ {
if (community.tick == SIMULATION_END) {
    filename = OUTPUT_TS;

    // add slendr-specific metadata to its own Dictionary key
    metadata = collect_metadata();

    sim.treeSeqOutput(OUTPUT_TS, metadata = Dictionary("slendr", metadata));

    sim.simulationFinished();
    catn("fucking done simulation finished");
    }
}

///
/// Interaction and fitness callbacks
///

///
/// Utility functions
///

// Set a default value of a command-line argument.
function (void) optional_arg(s arg, lifs default) {
    if (!exists(arg)) defineConstant(arg, default);
}

// Check if a required command-line argument was specified.
function (void) required_arg(s arg) {
    if (!exists(arg)) stop("Required argument '" + arg + "' is missing\n");
}

function (void) create_pop(object<Dictionary> pop) {
    pop_id = pop.getValue("pop_id");

    if (pop.getValue("parent") ==  "ancestor") {
        log_output("creating " + pop.getValue("pop") + "(p" + pop.getValue("pop_id") + ")");
        sim.addSubpop(pop_id, pop.getValue("N"));
    } else {
        log_output(
            "split of " + pop.getValue("pop") + "(p" + pop.getValue("pop_id") + ")" +
            " from " + pop.getValue("parent") + "(p" + pop.getValue("parent_id")  + ")"
        );
        sim.addSubpopSplit(pop_id, pop.getValue("N"), pop.getValue("parent_id"));
    }

    // dispersal distance is set in a script block (here we just create the variable)
    get_pop(pop_id).setValue("dispersal", -1);
    get_pop(pop_id).setValue("dispersal_fun", "");
}

// Get subpopulation object based on a given identifier
// (SLiM-based numerber or a user-defined string name)
function (lifso<Subpopulation>$) get_pop(si$ i) {
    if (isString(i)) i = filter(POPULATIONS, "pop", i).getValue("pop_id");
    if (!any(i == sim.subpopulations.id))
        stop("Population " + filter(POPULATIONS, "pop_id", i).getValue("pop") +
                 " not present in the simulation in generation " + community.tick);
    return sim.subpopulations[i == sim.subpopulations.id];
}

function (object<Dictionary>) collect_metadata(void) {
    metadata = Dictionary();

    // slendr version and commit hash that generated this script
    metadata.setValue("version", "__VERSION__");
    metadata.setValue("backend", "SLiM");

    metadata.setValue("description", DESCRIPTION);

    // sampling schedule table
    metadata.setValue("sampling", SAMPLING);

    if (SPATIAL) {
        spatial_metadata = Dictionary();
        // EPSG code of the CRS used
        spatial_metadata.setValue("crs", __CRS__);
        // coordinates of the bounding box of the map
        spatial_metadata.setValue("extent", __EXTENT__);
        // how many pixels per unit of distance (i.e. meters for projected CRS)
        spatial_metadata.setValue("resolution", __RESOLUTION__);
    } else
        spatial_metadata = NULL;

    metadata.setValue("map", spatial_metadata);

    metadata.setValue("arguments", Dictionary(
        "SEQUENCE_LENGTH", SEQUENCE_LENGTH,
        "RECOMB_RATE", RECOMB_RATE,
        "SEED", SEED,
        "BURNIN_LENGTH", BURNIN_LENGTH,
        "SIMULATION_LENGTH", SIMULATION_LENGTH,
        "MAX_ATTEMPTS", MAX_ATTEMPTS
    ));

    return(metadata);
}

///
/// Input/output functions
///

// Compose a path to a configuration file
function (s) config_path(s file) {
    return MODEL + "/" + file;
}

// Write the locations table header
function (void) write_locations_header(void) {
    filename = OUTPUT_LOCATIONS;
    header_str = "gen\tpop_id\tpop\tind\tx\ty";
    writeFile(filename, header_str, compress = T);
}

// Write the given log output message with the time stamp
function (void) log_output(s$ str) {
    catn("Generation " + community.tick + ": " + str);
}

///
/// Data frame functions
///

// Read a TSV file as a Dictionary of pairs of the form
// "column name" : <vector of column values>
function (object<Dictionary>) read_table(s$ path) {
    if (!fileExists(path)) return(NULL);

    lines = readFile(path);

    // extract column names
    columns = strsplit(lines[0], "\t");
    // parse the body of the table into individual elements
    body = lines[1 : (length(lines) - 1)];
    body_elements = sapply(body, "strsplit(applyValue, '\t');");

    // generate a dictionary of key-vector (pairs column-column values)
    dict = Dictionary();
    for (i in seqAlong(columns)) {
        // extract values of the i-th column by offseting into a one dimensional
        // vector of dataframe cells
        indices = seq(i, length(body_elements) - 1, by = length(columns));
        column_values = convert_type(columns[i], body_elements[indices]);

        dict.setValue(columns[i], column_values);
    }

    return dict;
}

// Filter the data frame `d` to rows where the `col` is equal to `val`
// (or not equal if `negate` is TRUE)
function (object<Dictionary>) filter(No<Dictionary> d, s$ col, ifsl val, [l$ negate = F]) {
    if (isNULL(d) | num_rows(d) == 0) return(NULL);

    if (!any(col == d.allKeys))
        stop("Column '" + col + "' not present in the table");

    values = d.getValue(col);

    matches = sapply(values, "any(applyValue == val);");
    if (negate) matches = !matches;

    return d.getRowValues(matches);
}

// Get the number of rows of the given dataframe
function (i$) num_rows(No<Dictionary>$ d) {
    if (isNULL(d)) return(0);

    columns = d.allKeys;
    lengths = sapply(columns, 'length(d.getValue(applyValue));');
    if (length(unique(lengths)) != 1)
        stop("Corrupted dataframe {" + paste(d.allKeys, sep = ", ") +
                 "} with columns of unequal length (" +
                 paste(lengths, sep = ", ") + ")");
    else
        return(unique(lengths));
}

// Pretty printer for Dictionary-based dataframe objects
function (void) print_table(object<Dictionary> d) {
    for (i in seqLen(num_rows(d))) {
        row = d.getRowValues(i);
        cat("row #" + i + "\n-------\n| ");
        for (c in d.allKeys) {
            val = row.getValue(c);
            if (!isFloat(val) & !isInteger(val) & !isString(val) & !isLogical(val))
                next;
            cat(c + ": " + val + " | ");
        }
        cat("\n\n");
    }
}

// Convert column vector values to a required type (this is hardcoded
// for every column among all slendr-generated TSV files)
function (ifsl) convert_type(s$ column_name, s string_values) {
    // vectors of all possible column names in tables defined by slendr `compile()`
    string = c("pop", "parent", "how", "path", "from", "to", "how", "dispersal_fun");
    integer = c("pop_id", "parent_id", "from_id", "to_id", "N", "prev_N",
                "time_orig", "time_gen",
                "tsplit_orig", "tsplit_gen", "tdispersal_orig", "tdispersal_gen",
                "tremove_orig", "tremove_gen", "tstart_orig", "tstart_gen",
                "tend_orig", "tend_gen", "tresize_orig", "tresize_gen");
    float = c("rate", "competition", "mating", "dispersal", "n",
              "x", "y", "x_orig", "y_orig");
    logical = c("overlap");

    if (any(column_name == integer))
        values = asInteger(string_values);
    else if (any(column_name == float))
        values = asFloat(string_values);
    else if (any(column_name == logical))
        values = asLogical(string_values);
    else if (any(column_name == string))
        values = asString(string_values);
    else
        stop("Unknown column '" + column_name + "' in a dataframe");

    return values;
}
