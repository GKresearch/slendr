# tree-sequence processing ------------------------------------------------

#' Load a tree-sequence file produced by a given model
#'
#' This function loads a tree-sequence file simulated from a given slendr model.
#' Optionally, the tree-sequence can be recapitated and simplified.
#'
#' The loading, recapitation and simplification is performed using the Python
#' module pyslim which serves as a link between tree-sequences generated by SLiM
#' and the tskit module for manipulation of tree-sequence data. All of these
#' steps have been modelled after the official pyslim tutorial and documentation
#' available at: <https://pyslim.readthedocs.io/en/latest/tutorial.html>.
#'
#' The recapitation and simplification steps can also be performed individually
#' using the functions \code{ts_recapitate} and \code{ts_simplify}.
#'
#' @param file Path to a tree-sequence file generated by SLiM
#' @param model Object of the class \code{slendr_model}
#' @param recapitate Should the tree-sequence be recapitated?
#' @param simplify Should the tree-sequence be simplified down to only
#'   remembered (i.e. "sampled", in slendr parlance) individuals?
#' @param recombination_rate,Ne Arguments passed to \code{ts_recapitate}
#' @param random_seed Random seed passed to pyslim's \code{recapitate} method
#'
#' @return SlimTreeSequence object
#'
#' @export
ts_load <- function(file, model, recapitate = FALSE, simplify = FALSE,
                    recombination_rate = NULL, Ne = NULL, random_seed = NULL) {
  if (recapitate && (is.null(recombination_rate) || is.null(Ne)))
    stop("Recombination rate and Ne must be specified for recapitation", call. = FALSE)

  ts <- pyslim$load(path.expand(file))

  # decorate the SlimTreeSequence object with a table of individuals
  # (this is to avoid having to drag the model object to each function
  # operating on the tree-sequence and requiring information about the
  # simulated individuals)
  attr(ts, "info") <- get_individuals(ts, model)
  class(ts) <- c("slendr_ts", class(ts))

  if (recapitate) {
    if (ts_coalesced(ts))
      message("No need to recapitate, all trees are coalesced")
    else
      ts <- ts_recapitate(ts, recombination_rate = recombination_rate, Ne = Ne,
                          random_seed = random_seed)
  }
  if (simplify)
    return(ts_simplify(ts))
  else
    return(ts)
}

#' Check that all trees in the tree-sequence are fully coalesced
#'
#' @param ts SlimTreeSequence object
#' @param return_failed Report back which trees failed the coalescence
#'   check?
#'
#' @return TRUE or FALSE value if \code{return_failed = FALSE}, otherwise a vector of
#'   (tskit Python 0-based) indices of trees which failed the coalescence test
#'
#' @export
ts_coalesced <- function(ts, return_failed = FALSE) {
  num_roots <- reticulate::iterate(ts$trees(), function(t) t$num_roots)
  if (all(num_roots == 1))
    return(TRUE)
  else if (return_failed)
    return(which(num_roots) - 1)
  else
    return(FALSE)
}

#' Add mutations to the given tree-sequence
#'
#' @param ts Object of the type SlimTreeSequence
#' @param mutation_rate Mutation rate used by msprime to simulate mutations
#' @param random_seed Random seed passed to msprime's \code{mutate} method
#'
#' @return SlimTreeSequence object
#'
#' @export
ts_mutate <- function(ts, mutation_rate, random_seed = NULL) {
  if (!inherits(ts, "slendr_ts"))
    stop("Not a tree sequence object created by ts_load, ts_simplify or ts_mutate", call. = FALSE)

  ts_mutated <-
    msprime$mutate(ts, rate = mutation_rate, keep = TRUE, random_seed = random_seed) %>%
    pyslim$SlimTreeSequence()

    # decorate the SlimTreeSequence object with a table of individuals
  attr(ts_mutated, "info") <- attr(ts, "info")
  class(ts_mutated) <- c("slendr_ts", class(ts_mutated))

  ts_mutated
}

#' Recapitate the tree-sequence
#'
#' @param ts SlimTreeSequence object loaded by \code{ts_load}
#' @param recombination_rate A constant value of the recombination rate
#' @param Ne Effective population size during the recapitation process
#' @param random_seed Random seed passed to pyslim's \code{recapitate} method
#'
#' @return @return SlimTreeSequence object accessed via the reticulate package
#'
#' @export
ts_recapitate <- function(ts, recombination_rate, Ne, random_seed = NULL) {
  if (!inherits(ts, "slendr_ts"))
    stop("Not a tree sequence object created by ts_load, ts_simplify or ts_mutate", call. = FALSE)

  individuals <- attr(ts, "info")

  new_ts <- ts$recapitate(recombination_rate = recombination_rate, Ne = Ne,
                          random_seed = random_seed)

  # decorate the SlimTreeSequence object with a table of individuals
  attr(new_ts, "info") <- get_individuals(new_ts, model)

  class(new_ts) <- c("slendr_ts", class(new_ts))
  new_ts
}

#' Simplify tree-sequence object down to sampled individuals
#'
#' @param ts SlimTreeSequence object
#'
#' @return @return SlimTreeSequence object accessed via the reticulate package
#'
#' @export
ts_simplify <- function(ts) {
  if (!inherits(ts, "slendr_ts"))
    stop("Not a tree sequence object created by ts_load, ts_simplify or ts_mutate", call. = FALSE)

  individuals <- attr(ts, "info")

  node_ids <- dplyr::filter(individuals, remembered) %>%
    dplyr::select(chr1_id, chr2_id) %>%
    unlist() %>%
    as.integer()

  new_ts <- ts$simplify(node_ids)

  # decorate the SlimTreeSequence object with a table of individuals
  attr(new_ts, "info") <- get_individuals(new_ts, model)

  class(new_ts) <- c("slendr_ts", class(new_ts))
  new_ts
}

#' Extract genotype table from the tree-sequence
#'
#' @param ts SlimTreeSequence object
#'
#' @return Data frame object of the class \code{tibble}
#'
#' @export
ts_genotypes <- function(ts) {
  genotypes <- ts$genotype_matrix()
  colnames(genotypes) <-
    ts_individuals(ts) %>%
    dplyr::select(chr1, chr2) %>%
    unlist() %>%
    as.character()
  dplyr::as_tibble(genotypes) %>%
    dplyr::mutate(pos = ts$tables$sites$position) %>%
    dplyr::select(pos, dplyr::everything())
}

#' Extract genotypes from the tree-sequence in the EIGENSTRAT format
#'
#' @param ts SlimTreeSequence object
#' @param prefix EIGENSTRAT trio prefix
#'
#' @return Object of the class EIGENSTRAT created by the admixr package
#'
#' @export
ts_eigenstrat <- function(ts, prefix, chrom = "chr1", quiet = FALSE) {
  chrom_genotypes <- ts_genotypes(ts)
  chr1_genotypes <- dplyr::select(chrom_genotypes, dplyr::ends_with("_chr1"))
  chr2_genotypes <- dplyr::select(chrom_genotypes, dplyr::ends_with("_chr2"))

  # create a geno file table
  geno <- dplyr::as_tibble(2 - (chr1_genotypes + chr2_genotypes))
  colnames(geno) <- ts_individuals(ts)$name

  # create an ind file table
  ind <- ts_individuals(ts) %>%
    dplyr::mutate(sex = "U") %>%
    dplyr::select(id = name, sex, label = name)

  # create a snp file table
  positions <- round(ts$tables$sites$position)
  snp <- dplyr::tibble(
    id = sprintf("%s_%s", chrom, as.character(positions)),
    chrom = chrom,
    gen = 0.0,
    pos = positions,
    ref = "G",
    alt = "T"
  )

  dup_muts <- duplicated(positions)
  if (any(dup_muts)) {
    message(sum(dup_muts), " mutations (out of ", nrow(snp), ") have been ",
            "removed because they appeared on a position already occupied by ",
            "another mutation. This is a consequence of mutations ",
            "positions in tskit being in floating-point values but normal ",
            "genomic locations being integer values.")
    snp <- snp[!dup_muts, ]
    geno <- geno[!dup_muts, ]
  }

  # save the EIGENSTRAT trio
  if (!dir.exists(dirname(prefix))) dir.create(dirname(prefix))
  admixr::write_geno(geno, paste0(prefix, ".geno"))
  admixr::write_snp(snp, paste0(prefix, ".snp"))
  admixr::write_ind(ind, paste0(prefix, ".ind"))

  # return the admixr eigenstrat object
  admixr::eigenstrat(prefix = prefix)
}

#' Save genotypes in the tree-sequence as a VCF file
#'
#' @param ts SlimTreeSequence object
#' @param vcf Path to a VCF file
#' @param individuals A character vector of individuals in the tree-sequence
#'   (all individuals present in the tree-sequence will be saved by default)
#'
#' @export
ts_vcf <- function(ts, vcf, individuals = NULL) {
  if (is.null(individuals)) individuals <- ts_individuals(ts)$name

  present <- individuals %in% ts_individuals(ts)$name
  if (!all(present))
    stop("", paste(individuals[!present], collapse = ", "),
         " not present in the tree-sequence", call. = FALSE)

  individual_ids <- ts_individuals(ts) %>%
    dplyr::filter(name %in% individuals) %>%
    .[["id"]]

  gzip <- reticulate::import("gzip")
  with(reticulate::`%as%`(gzip$open(path.expand(vcf), "wt"), vcf_file), {
    ts$write_vcf(vcf_file,
                 individuals = individual_ids,
                 individual_names = individuals)
  })
}

#' Extract table of individuals from pyslim's tree-sequence object
#'
#' @param ts SlimTreeSequence object
#' @param model \code{slendr_model} object of a model that generated the data
#'
#' @return Data frame with individual information from the input tree-sequence
#'   object
#'
#' @export
ts_individuals <- function(ts) {
  if (!inherits(ts, "slendr_ts"))
    stop("Not a tree sequence object created by ts_load, ts_simplify or ts_mutate", call. = FALSE)
  attr(ts, "info")
}

#' Extract the nodes belonging to a given set of individuals
#'
#' @param ts SlimTreeSequence object
#' @param ind A character vector of individual names
#'
#' @return An integer vector with node numbers
#'
#' @export
ts_nodes <- function(ts, ind) {
  if (!inherits(ts, "slendr_ts"))
    stop("Not a tree sequence object created by ts_load, ts_simplify or ts_mutate", call. = FALSE)

  attr(ts, "info") %>%
    dplyr::filter(name %in% ind) %>%
    dplyr::select(chr1_id, chr2_id) %>%
    unlist() %>%
    as.integer()
}

# f-statistics ------------------------------------------------------------

fstat <- function(ts, stat, sample_sets, mode, windows, span_normalise) {
  if (!stat %in% c("f2", "f3", "f4"))
    stop("Unknown statistic '", stat, "'", call. = FALSE)

  if (!is.null(windows)) windows <- define_windows(ts, windows)

  node_sets <- purrr::map(sample_sets, ~ ts_nodes(ts, .x))

  result <- ts[[stat]](sample_sets = node_sets, mode = mode,
                       span_normalise = TRUE, windows = windows)

  if (length(result) > 1) result <- list(result)
  result
}

#' @rdname ts_f4ratio
ts_f2 <- function(ts, A, B, mode = c("site", "branch", "node"),
                  span_normalise = TRUE, windows = NULL) {
  mode <- match.arg(mode)
  result <- fstat(ts, "f2", list(A, B), mode, windows, span_normalise)
  dplyr::tibble(A = concat(A), B = concat(B), f2 = result)
}

#' @rdname ts_f4ratio
ts_f3 <- function(ts, A, B, C, mode = c("site", "branch", "node"),
                  span_normalise = TRUE, windows = NULL) {
  mode <- match.arg(mode)
  result <- fstat(ts, "f3", list(A, B, C), mode, windows, span_normalise)
  dplyr::tibble(A = concat(A), B = concat(B), C = concat(C), f3 = result)
}

#' @rdname ts_f4ratio
ts_f4 <- function(ts, W, X, Y, Z, mode = c("site", "branch", "node"),
                  span_normalise = TRUE, windows = NULL) {
  mode <- match.arg(mode)
  result <- fstat(ts, "f4", list(W, X, Y, Z), mode, windows, span_normalise)
  dplyr::tibble(W = concat(W), X = concat(X), Y = concat(Y), Z = concat(Z),
                f4 = result)
}

#' Calculate the f2, f3, f4, and f4-ratio statistics
#'
#' @param ts SlimTreeSequence object
#' @param w,x,y,z,a,b,c,o Character vectors of  individual names (following the
#'   nomenclature of Patterson et al. 2021)
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#'
#' @return Numeric estimate of ancestry proportion
#'
#' @export
ts_f4ratio <- function(ts, X, A, B, C, O, mode = c("site", "branch"), span_normalise = TRUE) {
  mode <- match.arg(mode)

  purrr::map_dfr(
    X, function(.x) {
      alpha <-
        ts_f4(ts, A, O, .x, C, mode = mode)$f4 /
        ts_f4(ts, A, O, B, C, mode = mode)$f4
      dplyr::tibble(X = .x, A = concat(A), B = concat(B),
                    C = concat(C), O = concat(O), alpha)
    }
  )
}

# multiway statistics -----------------------------------------------------

multiway_stat <- function(ts, stat = c("fst", "divergence"),
                          k, sample_sets, mode, windows, span_normalise) {
  stat <- match.arg(stat)
  node_sets <- purrr::map(sample_sets, function(set) {
    ts_nodes(ts, set)
  })

  n_sets <- length(sample_sets)

  # generate all pairwise indexes required by tskit for more than
  # two sample sets
  indexes <- combn(n_sets, m = k, simplify = FALSE,
                   FUN = function(x) as.integer(x - 1))

  fun <- switch(
    stat,
    "fst" = ts[["Fst"]],
    "divergence" = ts[["divergence"]]
  )
  if (is.null(fun))
    stop("Unknown statistic '", stat, "'", call. = FALSE)

  values <- fun(
    sample_sets = unname(node_sets),
    indexes = indexes,
    mode = mode,
    windows = windows,
    span_normalise = span_normalise
  )
  if (is.matrix(values))
    values <- split(values, col(values))

  if (is.null(names(sample_sets)))
    set_names <- paste0("set_", seq_len(n_sets))
  else
    set_names <- names(sample_sets)

  result <- purrr::map_dfr(indexes, ~ {
    set <- set_names[.x + 1]
    as.data.frame(t(matrix(set)), stringsAsFactors = FALSE)
  }) %>%
    dplyr::as_tibble() %>%
    dplyr::mutate(stat = values)

  result
}

#' Calculate pairwise Fst between sets of individuals
#'
#' For a discussion on the difference between "site", "branch", and "node"
#' options of the \code{mode} argument, please see the tskit documentation at
#' <https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode>.
#'
#' @param tsSlimTreeSequence object
#' @param sample_sets A list (optionally a named list) of character vectors with
#'   individual names (one vector per set)
#' @param mode The mode for the calculation ("sites" or "branch")
#' @param windows Coordinates of breakpoints between windows. The first
#'   coordinate (0) and the last coordinate (equal to \code{ts$sequence_length})
#'   do not have to be specified as they are added automatically.
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#'
#' @return For each pairwise calculation, either a single Fst value or a vector
#'   of Fst values (one for each window)
#'
#' @export
ts_fst <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                   windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  multiway_stat(ts, "fst", k = 2, sample_sets, mode, windows, span_normalise) %>%
    setNames(c("x", "y", "Fst"))
}

#' Calculate pairwise divergence between sets of individuals
#'
#' @rdname ts_fst
#'
#' @return For each pairwise calculation, either a single divergence value or a
#'   vector of divergence values (one for each window)
#'
#' @export
ts_divergence <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                   windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  multiway_stat(ts, "divergence", k = 2, sample_sets, mode, windows, span_normalise) %>%
    setNames(c("x", "y", "divergence"))
}

# oneway statistics -------------------------------------------------------

oneway_stat <- function(ts, stat, sample_sets, mode, windows, span_normalise = NULL) {
  node_sets <- purrr::map(sample_sets, function(set) {
    ts_nodes(ts, set)
  })

  n_sets <- length(sample_sets)

  fun <- switch(
    stat,
    "D" = ts[["Tajimas_D"]],
    "diversity" = ts[["diversity"]],
    "segsites" = ts[["segregating_sites"]]
  )
  if (is.null(fun))
    stop("Unknown statistic '", stat, "'", call. = FALSE)

  args <- list(sample_sets = unname(node_sets),
               mode = mode,
               windows = windows)
  if (!is.null(span_normalise)) args[["span_normalise"]] <- span_normalise

  values <- do.call(fun, args)

  if (is.matrix(values))
    values <- split(values, col(values))

  if (is.null(names(sample_sets)))
    set_names <- paste0("set_", seq_len(n_sets))
  else
    set_names <- names(sample_sets)

  result <- dplyr::tibble(set = set_names)
  result[[stat]] <- values
  result
}

#' Calculate the density of segregating sites for the given sets of individuals
#'
#' @inheritParams ts_tajima
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#'
#' @return For each set of individuals either a single diversity value or a
#'   vector of diversity values (one for each window)
#'
#' @export
ts_segregating <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                           windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  oneway_stat(ts, "segsites", sample_sets, mode, windows, span_normalise)
}

#' Calculate diversity in given sets of individuals
#'
#' @inheritParams ts_tajima
#' @param span_normalise Divide the result by the span of the window? Default
#'   TRUE, see the tskit documentation for more detail.
#'
#' @return For each set of individuals either a single diversity value or a
#'   vector of diversity values (one for each window)
#'
#' @export
ts_diversity <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                         windows = NULL, span_normalise = TRUE) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  oneway_stat(ts, "diversity", sample_sets, mode, windows, span_normalise)
}

#' Calculate Tajima's D for given sets of individuals
#'
#' For a discussion on the difference between "site" and "branch" options of the
#' \code{mode} argument, please see the tskit documentation at
#' <https://tskit.dev/tskit/docs/stable/stats.html#sec-stats-mode>
#'
#' @param tsSlimTreeSequence object
#' @param sample_sets A list (optionally a named list) of character vectors with
#'   individual names (one vector per set)
#' @param mode The mode for the calculation ("sites" or "branch")
#' @param windows Coordinates of breakpoints between windows. The first
#'   coordinate (0) and the last coordinate (equal to \code{ts$sequence_length})
#'   are added automatically)
#'
#' @return For each set of individuals either a single Tajima's D value or a
#'   vector of Tajima's D values (one for each window)
#'
#' @export
ts_tajima <- function(ts, sample_sets, mode = c("site", "branch", "node"),
                      windows = NULL) {
  mode <- match.arg(mode)
  if (!is.list(sample_sets)) sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)
  oneway_stat(ts, "D", sample_sets, mode, windows)
}

# other statistics --------------------------------------------------------

#' Compute the allele frequency spectrum (AFS)
#'
#' This function computes the AFS with respect to the given set of individuals
#'
#' For more information on the format of the result and dimensions, in
#' particular the interpretation of the first and the last element of the AFS,
#' please see the tskit manual at
#' <https://tskit.dev/tskit/docs/stable/tutorial.html#sec-tutorial-afs-zeroth-entry>
#'
#' @param tsSlimTreeSequence object
#' @param sample_sets A list (optionally a named list) of character vectors with
#'   individual names (one vector per set). If NULL, allele frequency spectrum
#'   for all individuals in the tree-sequence will be computed.
#' @param mode The mode for the calculation ("sites" or "branch")
#' @param windows Coordinates of breakpoints between windows. The first
#'   coordinate (0) and the last coordinate (equal to \code{ts$sequence_length})
#'   are added automatically)
#' @param polarised When FALSE (the default) the allele frequency spectrum will
#'   be folded (i.e. the counts will not depend on knowing which allele is
#'   ancestral)
#'
#' @return Either a single Fst value or a vector of Fst values (one for each
#'   window)
#'
#' @export
ts_afs <- function(ts, sample_sets = NULL, mode = c("site", "branch", "node"),
                   windows = NULL, span_normalise = TRUE,
                   polarised = FALSE) {
  mode <- match.arg(mode)
  if (is.null(sample_sets))
    sample_sets <- list(ts_individuals(ts)$name)
  else if (!is.list(sample_sets))
    sample_sets <- list(sample_sets)
  if (!is.null(windows)) windows <- define_windows(ts, windows)

  node_sets <- purrr::map(sample_sets, function(set) {
    ts_nodes(ts, set)
  })

  result <- ts$allele_frequency_spectrum(
    sample_sets = unname(node_sets),
    mode = mode,
    windows = windows,
    span_normalise = span_normalise,
    polarised = polarised
  )

  result
}


# tree-sequence utility functions -----------------------------------------

define_windows <- function(ts, breakpoints) {
  unique(c(0, breakpoints, ts$sequence_length))
}

concat <- function(x) {
  paste(x, collapse = "+")
}

get_individuals <- function(ts, model) {
  # extract information about individuals from the tree-sequence
  individuals <-
    purrr::map_dfr(seq(0, ts$num_individuals - 1), function(i) {
      ind <- ts$individual(i)
      list(
        id = ind["id"],
        pedigree_id = ind["metadata"]["pedigree_id"],
        chr1_id = ind["nodes"][1],
        chr2_id = ind["nodes"][2],
        time = ind["time"],
        loc_x = ind["location"][1],
        loc_y = ind["location"][2],
        pop_id = ind["metadata"]["subpopulation"],
        flag = ind["flags"],
        alive = bitwAnd(ind["flags"], pyslim$INDIVIDUAL_ALIVE) != 0,
        remembered = bitwAnd(ind["flags"], pyslim$INDIVIDUAL_REMEMBERED) != 0,
        retained = bitwAnd(ind["flags"], pyslim$INDIVIDUAL_RETAINED) != 0
      )
    }) %>%
    dplyr::mutate(pop = model$splits$pop[pop_id + 1]) %>%
    dplyr::arrange(-time, pop) %>%
    dplyr::select(-pop, -time)

  # load sampling times table (expand multiple samplings at a single time point
  # into one record per each individual to matche the number of rows in the
  # table extract from the tree-sequence above)
  samples <- file.path(model$path, "script_samples.tsv") %>%
    readr::read_tsv(col_types = "ciii") %>%
    {
      rbind(
        dplyr::filter(., n == 1),
        dplyr::filter(., n > 1) %>% .[rep(seq_len(nrow(.)), .$n), ]
      )
    } %>%
    dplyr::group_by(pop) %>%
    dplyr::mutate(name = paste0(pop, 1:dplyr::n()),
                  chr1 = paste0(pop, 1:dplyr::n(), "_chr1"),
                  chr2 = paste0(pop, 1:dplyr::n(), "_chr2")) %>%
    dplyr::ungroup() %>%
    dplyr::arrange(-time_orig, pop) %>%
    dplyr::rename(time = time_orig) %>%
    dplyr::select(pop, name, time, chr1, chr2)

  # splits individuals extracted from the tree-sequence into those remembered
  # (i.e. individuals present in the sampling table) and those that are not
  remembered <- dplyr::filter(individuals, remembered)
  not_remembered <- dplyr::filter(individuals, !remembered)

  # combine everything together - first merge sampling information for
  # remembered individuals, then concatenate this with everyone else
  combined <-
    cbind(remembered, samples) %>%
    dplyr::bind_rows(not_remembered) %>%
    dplyr::select(name, id, pop, time, chr1_id, chr2_id,
                  chr1, chr2, loc_x, loc_y, pedigree_id,
                  dplyr::everything()) %>%
    dplyr::as_tibble()

  combined
}
