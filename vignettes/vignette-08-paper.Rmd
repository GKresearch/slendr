---
title: "Examples from the slendr paper"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Examples from the slendr paper}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r, include = FALSE}
env_present <- "automatic_slendr_python_env" %in% reticulate::conda_list()$name

knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#>",
  fig.width = 6,
  fig.height = 4,
  dpi = 80,
  eval = FALSE #Sys.which("slim") != "" && env_present
)
```

```{r}
# library(slendr)
devtools::load_all(".")

library(dplyr)
library(ggplot2)
library(purrr)
library(tidyr)
library(cowplot)
library(forcats)
library(ggtree)

SEED <- 42
set.seed(SEED)
```

Automatically setup the Python environment with all dependencies for tree sequence processing and analysis:

```{r}
setup_env()
check_env()
```

## Example 1

```{r}
o <- population("o", time = 1, N = 100)
c <- population("c", time = 2500, N = 100, parent = o)
a <- population("a", time = 3000, N = 100, parent = c)
b <- population("b", time = 3500, N = 100, parent = a)
x1 <- population("x1", time = 3800, N = 10000, parent = c)
x2 <- population("x2", time = 4000, N = 10000, parent = x1)

gf <- gene_flow(from = b, to = x1, start = 4100, end = 4150, 0.1)

model <- compile_model(
  populations = list(o, a, b, c, x1, x2), geneflow = gf,
  generation_time = 1, sim_length = 4500
)

plot_model(model, sizes = FALSE, proportions = TRUE)

msprime(model, sequence_length = 100e6, recombination_rate = 1e-8)

ts <- ts_load(model) %>% ts_mutate(mutation_rate = 1e-8)

samples <- ts_samples(ts) %>% group_by(pop) %>% sample_n(100)

divergence <- ts_divergence(ts, split(samples$name, samples$pop))

f4ratio <- ts_f4ratio(
  ts, X = filter(samples, pop %in% c("x1", "x2"))$name,
  A = "a_1", B = "b_1", C = "c_1", O = "o_1"
)
```

<!-- ```{r} -->
<!-- f4ratio %>% inner_join(samples, by = c("X" = "name")) %>% ggplot(aes(pop, alpha, color = pop)) + geom_boxplot() + geom_jitter() + geom_hline(yintercept = 0) -->
<!-- ``` -->


```{r class.source = "fold-hide"}
slim(model, sequence_length = 100e6, recombination_rate = 1e-8, random_seed = SEED)

ts_slim <- ts_load(model, file = file.path(model$path, "output_slim.trees")) %>% ts_mutate(mutation_rate = 1e-8)

divergence_slim <- ts_divergence(ts_slim, split(samples$name, samples$pop))

f4ratio_slim <- ts_f4ratio(
  ts_slim, X = filter(samples, pop %in% c("x1", "x2"))$name,
  A = "a_1", B = "b_1", C = "c_1", O = "o_1"
)
```

<!-- ```{r} -->
<!-- f4ratio_slim %>% inner_join(samples, by = c("X" = "name")) %>% ggplot(aes(pop, alpha, color = pop)) + geom_boxplot() + geom_jitter() + geom_hline(yintercept = 0) -->
<!-- ``` -->

```{r class.source = "fold-hide"}
divergence_both <- bind_rows(
  divergence %>% mutate(backend = "msprime"),
  divergence_slim %>% mutate(backend = "SLiM")
) %>%
  mutate(pair = paste0(x, "\u2014", y))

f4ratio_both <- bind_rows(
  f4ratio %>% mutate(backend = "msprime"),
  f4ratio_slim %>% mutate(backend = "SLiM")
) %>% mutate(population = gsub("^(.*)_.*$", "\\1", X), alpha = alpha * 100)

p_ex3_divergence <- divergence_both %>%
  ggplot(aes(fct_reorder(pair, divergence), color = backend, shape = backend, divergence)) +
  geom_point(size = 3) +
  xlab("population pair") + ylab("pairwise divergence") +
  theme_minimal() +
  scale_alpha_manual(values = c(1, 0.25)) +
  scale_color_manual(values = c("black", "darkgray")) +
  guides(shape = guide_legend("slendr simulation engine used:"),
         color = guide_legend("slendr simulation engine used:",
                              override.aes = list(size = 3))) +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 11),
        axis.text.x = element_text(hjust = 1, angle = 45, size = 10),
        axis.title.x = element_blank())#; p_ex3_divergence

p_ex3_f4ratio <- f4ratio_both %>%
  ggplot(aes(population, alpha)) + 
  geom_hline(yintercept = 0, linetype = 2) +
  geom_jitter(aes(color = backend, shape = backend), alpha = 0.75, size = 2,
              position = position_jitterdodge(jitter.width = 0.25)) +
  geom_boxplot(aes(group = interaction(population, backend), fill = population),
                   alpha = 0.75, size = 0.25, outlier.shape = NA) +
  # ylab(base::expression("ancestry from"~italic("b")~"[%]")) +
  ylab(base::expression(italic("f")[4]~"-ratio ancestry proportion [%]")) +
  scale_color_manual(values = c("black", "darkgray")) +
  scale_fill_manual(values = scales::hue_pal()(6)[c(5, 6)]) +
  theme_minimal() +
  theme(legend.position = "none",
        axis.text.x = element_text(size = 11),
        axis.title.x = element_blank(),
        panel.grid.major.x = element_blank())#; p_ex3_f4ratio

# let's avoid ggpubr as another dependency:
# https://github.com/kassambara/ggpubr/blob/master/R/as_ggplot.R#L27
p_ex3_legend <- ggdraw() + draw_grob(grid::grobTree(get_legend(p_ex3_divergence)))

p_ex3_model <- plot_model(model, sizes = FALSE, proportions = TRUE)

plot_grid(
  p_ex3_model,
  plot_grid(
    p_ex3_divergence + theme(legend.position = "none"),
    p_ex3_f4ratio,
    ncol = 2, rel_widths = c(1, 0.8), labels = c("C", "D")
  ),
  p_ex3_legend, nrow = 3, rel_heights = c(1, 1, 0.1),
  labels = "B"
)
```

## Example 2

In the second model, we demonstrate the possibility to finely tune within-population spatial dynamics using parameters which determine how clustered or uniformly distributed individuals are over the population boundary, and affect their dispersal and mating behavior. We define nine isolated populations which occupy a circular "island", each with an increasing value of the so-called "competition distance" parameter which controls to what distance does a given individual compete. Based on the value of this parameter, the number of individuals in the population and the size of the occupiable space, different spatial dynamic behavior emerges from the population.

```{r}
map <- world(xrange = c(0, 10), yrange = c(0, 10),
             landscape = region(center = c(5, 5), radius = 5))

p1 <- population("pop1", time = 1, N = 2000, map = map, competition_dist = 0)
p2 <- population("pop2", time = 1, N = 2000, map = map, competition_dist = 9)
p3 <- population("pop3", time = 1, N = 2000, map = map, competition_dist = 6)
p4 <- population("pop4", time = 1, N = 2000, map = map, competition_dist = 5)
p5 <- population("pop5", time = 1, N = 2000, map = map, competition_dist = 4)
p6 <- population("pop6", time = 1, N = 2000, map = map, competition_dist = 3)
p7 <- population("pop7", time = 1, N = 2000, map = map, competition_dist = 2)
p8 <- population("pop8", time = 1, N = 2000, map = map, competition_dist = 1)

model <- compile_model(
  populations = list(p1, p2, p3, p4, p5, p6, p7, p8),
  generation_time = 1, sim_length = 5000, resolution = 0.1,
  mate_dist = 0.1, dispersal_dist = 0.05
)

slim(model, sequence_length = 10e6, recombination_rate = 1e-8, method = "batch")

ts <- ts_load(model) %>% ts_simplify() %>% ts_mutate(mutation_rate = 1e-7)

diversity <- ts_samples(ts) %>%
  group_by(pop) %>%
  sample_n(100) %>%
  mutate(pi = ts_diversity(ts, name)$diversity)
```

```{r class.source = "fold-hide"}
locations <- ts_data(ts) %>% filter(time == 5001)

p_ex2_clustering <- ggplot() +
  geom_sf(data = map) +
  geom_sf(data = locations, aes(color = pop), size = 0.05, alpha = 0.25) +
  facet_grid(. ~ pop, switch = "x") +
  xlab("spatial distributions emerged from the simulation") +
  theme(
    strip.background = element_blank(),
    strip.text = element_text(size = 11),
    panel.grid = element_blank(),
    axis.ticks = element_blank(),
    axis.text = element_blank(),
    panel.background = element_blank()
  ) +
  guides(color = "none")#; p_ex2_clustering

p_ex2_diversity <- ggplot(diversity, aes(pop, pi, color = pop)) +
  geom_violin(color = "black") +
  geom_jitter(alpha = 0.5) +
  labs(y = "individual heterozygosity") +
  guides(color = "none") +
  theme_minimal() +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(), panel.grid.major.x = element_blank(),
        plot.margin = margin(t = 0.2, r = 0.2, b = -0.1, l = 0.2, "cm"))#; p_ex2_diversity

plot_grid(
  p_ex2_diversity,
  p_ex2_clustering +
    theme(plot.margin = margin(t = 0, r = 0.5, b = 0, l = 1.9, "cm")),
  nrow = 2,
  rel_heights = c(1, 0.5),
  labels = c("B", "C")
)
```

## Example 3

```{r class.source = 'fold-hide', results='hide'}
map <- world(xrange = c(-15, 60), yrange = c(20, 65), crs = 3035)

R1 <- region(
  "EHG range", map,
  polygon = list(c(26, 55), c(38, 53), c(48, 53), c(60, 53),
                 c(60, 60), c(48, 63), c(38, 63), c(26, 60))
)
R2 <- region(
  "Europe", map,
  polygon = list(
    c(-8, 35), c(-5, 36), c(10, 38), c(20, 35), c(25, 35),
    c(33, 45), c(20, 58), c(-5, 60), c(-15, 50)
  )
)
R3 <- region(
  "Anatolia", map,
  polygon = list(c(28, 35), c(40, 35), c(42, 40),
                 c(30, 43), c(27, 40), c(25, 38))
)
R4 <- join(R2, R3)
R5 <- region(
  "YAM range", map,
  polygon = list(c(26, 50), c(38, 49), c(48, 50),
                 c(48, 56), c(38, 59), c(26, 56))
)

ooa_trajectory <- list(c(40, 30), c(50, 30), c(60, 40), c(45, 55))
```

```{r}
map <- world(xrange = c(-15, 60), yrange = c(20, 65), crs = 3035)
 
ooa <- population(
  "OOA", time = 60000, N = 500, remove = 23000,
   map = map, center = c(33, 30), radius = 400e3
) %>%
  move(trajectory = ooa_trajectory, start = 50000, end = 40000, snapshots = 30)

ehg <- population(
  "EHG", time = 28000, N = 1000, parent = ooa, remove = 6000,
  map = map, polygon = R1
)

eur <- population(
  "EUR", time = 30000, N = 2000, parent = ooa,
  map = map, polygon = R2
) %>%
  resize(N = 10000, time = 5000, end = 0, how = "exponential")

ana <- population(
  "ANA", time = 25000, N = 4000, parent = ooa, remove = 3000,
  map = map, polygon = R3
) %>%
  expand_range(by = 3e6, start = 10000, end = 7000, polygon = R4, snapshots = 15)

yam <- population(
  "YAM", time = 7000, N = 600, parent = ehg, remove = 2500,
  map = m, polygon = R5
) %>%
  move(trajectory = list(c(15, 50)), start = 5000, end = 3000, snapshots = 10)

gf <- list(
  gene_flow(ana, to = yam, rate = 0.5, start = 6500, end = 5000),
  gene_flow(ana, to = eur, rate = 0.5, start = 8000, end = 6000),
  gene_flow(yam, to = eur, rate = 0.5, start = 3500, end = 3000)
)

model <- compile_model(
  path = "~/Desktop/model", overwrite = TRUE, force = TRUE,
  populations = list(ooa, ehg, eur, ana, yam), gene_flow = gf,
  generation_time = 30, resolution = 10e3,
  competition_dist = 130e3, mate_dist = 100e3,
  dispersal_dist = 70e3,
)

samples <- schedule_sampling(
  model, times = seq(0, 50000, by = 1000),
  list(ehg, 20), list(ana, 20), list(yam, 20), list(eur, 20)
)

# plot_map(model)
plot_model(model)

slim(
  model, burnin = 200000, sampling = samples,
  sequence_length = 200000, recombination_rate = 1e-8, verbose = TRUE
)
```

```{r, figure_ex3, fig.height=7, fig.width=3}
plot_grid(
  plot_model(model),
  plot_map(model) + theme(legend.position = "bottom") + guides(alpha = "none"),
  labels = c("B", "C"), nrow = 2, rel_heights = c(1, 1)
)
```

```{r}
animate_model(model, steps = 100)
```

## Example 4

In the fourth and final example, we return to the abstract toy model of West Eurasian prehistory. The main output of a _slendr_ simulation is a tree sequence which, in case of _non-spatial_ population genetic models, records the complete information about _when_ did the ancestors of a set of sampled individuals lived throughout the entire history of that sample. However, in case of _spatial_ _slendr_ models simulated by SLiM, the output tree sequences also contain the exact _spatial location_ of each individual ancestral node.

To highlight the richness of the spatio-temporal information encoded by tree sequence data structure and showcase the novel, we demonstrate 


```{r}
pdf("~/Desktop/x.pdf")
for (i in ts_samples(ts) %>% dplyr::filter(pop == "EUR") %>% dplyr::pull(name)) {
  lineages <- ts_ancestors(ts, i, verbose = TRUE)
  { plot_ancestors(lineages, i) + ggtitle(i) } %>% print
}
dev.off()
```


```{r}
# `model` below as created in Example 3
model <- read_model("~/Desktop/model")
map = model$world

ts <- ts_load(model)
ts <- ts_load(model, simplify = TRUE)

names <- ts_samples(ts)$name %>% sample(4)
ts <- ts_load(model) %>% ts_simplify(names)

ts_tree(ts, 1) %>% ts_draw(labels = TRUE, time_scale = "rank")

tree <- ts_phylo(ts, i = 1, labels = "tskit")

nodes <- ts_data(tree)
branches <- ts_branches(tree)

ancestors <- ts_ancestors(ts, "ANA_9")
plot_ancestors(ancestors)
```

```{r}
df <- as_tibble(tree) %>% select(node, label) %>% mutate(pop = gsub("^(.*)_.*", "\\1", label))

p_tree <- ggtree(tree) %<+% df +
  geom_tiplab(hjust = -0.) +
  geom_label2(aes(label = label, fill = pop, subset = !isTip)) +
  guides(fill = guide_legend("ancestral node origin",
                             override.aes = aes(label = ""))) +
  hexpand(0.15) +
  theme(legend.position = "bottom"); p_tree

# plot.margin = margin(t = 1, r = 1, b = 1, l = 1, "cm")
p_map <- ggplot() +
  geom_sf(data = map, aes(frame = NULL), fill = "lightgray", color = NA) +
  geom_sf(data = branches, size = 0.5, alpha = 0.5) +
  geom_sf(data = filter(nodes, is.na(name)),
          aes(color = pop, shape = pop), size = 5) +
  geom_sf_label(data = filter(nodes, is.na(name)),
                aes(label = phylo_id, fill = pop), size = 3) +
  geom_sf_label(data = nodes, aes(label = name), size = 3) +
  # coord_sf(xlim = c(3147066.1, 8688656.9),
  #          ylim = c(1517021.7, 4972983.3), expand = 0) +
  labs(x = "longitude", y = "latitude") +
  guides(color = "none", fill = "none", shape = "none") +
  theme_bw(); p_map

p_legend <- ggdraw() + draw_grob(grid::grobTree(get_legend(p_tree)))

plot_grid(
  plot_grid(NULL, p_tree + theme(legend.position = "none"), NULL, nrow = 1,
            rel_widths = c(0.7, 1, 0.7)),
  p_legend, p_map,
  ncol = 1, rel_heights = c(1, 0.1, 1)
)
```

